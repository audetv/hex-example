# hex-example
Example of Hexagonal Architecture for training course at Geekbrains. Repeating the code step by step.

Тренируем:
1. Создание сервера и клиента HTTP
2. Передачу json-данных в запросах и ответах (в т.ч. потоково)
3. Тестирование с помощью httptest

Задача:

Создать простой CRUD-сервер регистрации пользователей (система хранения - в памяти).

Сервер должен поддерживать операции:
- Создание профиля пользователя в виде json
- Удаление профиля по уникальному идентификатору
- Чтение профиля по уникальному идентификатору
- Получение всех профилей по части имени

Дополнительны требования:
- Hexagonal architecture
- Graceful shutdown
- Basic auth middleware
- Стриминг получения списка профилей, с выдачей ошибки в любой момент, если потребуется (имитация ошибки в системе хранения)

### Choosing a router
Выбор роутера

https://www.statista.com/statistics/1083219/worldwide-api-performance/

- почему нужны фреймворки http-роутеров:
    1. неудобно разделять методы
    2. неудобно обрабатывать параметры
    3. неудобно организовывать мидлвары
    4. скорость маршрутизации, количество аллокаций
    5. скорость разработки - должен быть первым в списке.

Посмотрим: gorilla/mux, go-chi, gin

https://github.com/mingrammer/go-web-framework-stars

- переведем пример с прошлого урока на chi

- go get -u github.com/deepmap/oapi-codegen/cmd/oapi-codegen
  //go:generate oapi-codegen -generate chi-server,spec -package api -o ./api/api.go ./api.oapi3.yaml
- https://goswagger.io/ - генерация swagger по комментариям

- gin-swagger : code first vs schema first
- https://github.com/swaggo

Есть 
1. Фреймворки оперирующие стандартными хэнлерами, стандартной библиотеки. Работают немного улучшая юзабилити стандартной библиотеки.
2. Другой класс идет по пути изобретения своих стандартов и хэнлеров в своем формате, как правило, это является некий внутренний контекст этого фреймворка и он, так и передается как контекст. Обычно имеют еще различные дополнительные возможности.
3. Не только предоставляют свой собственный синтаксис организации хэндлеров, но они так же заменяют еще и серверную часть: http.server и делают это из соображения производительности.
 
https://github.com/smallnest/go-web-framework-benchmark

Используйте тот, который удобнее вам.
Отдельно скорость роутера не имеет решающего значения, исходить надо от общего быстродействие всей системы, которое может зависеть от:
базы данных, микросервисов и взаимодействие между ними, k8, nginx и многое другое, в совокупности это все больше влияет на быстродействие системы, а не скорость роутера.

Gin - 2ая категория, у него есть свой контекст. Он сам комбайн и к нему много всего идет в дополнение. Может почти все.
Один из возможных минусов - это свой формат хэндлеров, вместо стандартных writer and reader работает со своим контекстом запросов в своем формате.

fasthttp - 3ая категория. Чемпион по экономии памяти, шарит память между хэндлерами, с этими особенностями надо уметь мириться.
Хэндлеры работают с сырыми данными, находящимися в запросе в одном месте, эти данные потом переиспользуются другими запросами. Конкурентность там нельзя организовать нормальную.

mux - Один из первых и самых простых. Можно сказать, прородитель фреймворков Относится к 1ой категории.
Использует хэндлеры стандартного вида и добавляет функционал, типа
переменных в запросе, custom url с параметрами, в том числе с регулярными выражениями.
Можно подключать разные доп обработки, удобные мидлвары через use

Chi - 1ая категория, удобный по api и по набору middleware.